--[[
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║                        KANISTAY KEY VALIDATOR v4.0                           ║
    ║                     ENHANCED DEBUG & SECURITY SYSTEM                         ║
    ║                        COMPATIBLE WITH LUA 5.1/5.2                          ║
    ╚══════════════════════════════════════════════════════════════════════════════╝
]]--

-- CRITICAL SECURITY CONFIGURATION
local SECURITY_CONFIG = {
    MASTER_TOKEN = "KANI_SECURE_2024_V4",
    SIGNATURE_KEY = "KanistayMasterSig2024Enhanced",
    PRIMARY_XOR_KEY = "KanistaySecureXOR2024Enhanced",
    SECONDARY_XOR_KEY = "ValidatorEncrypt2024Enhanced",
    API_VALIDATION_HASH = "9f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c",
    SESSION_TOKEN = tostring(math.random(100000, 999999)) .. "_" .. tostring(os.time()),
    DEBUG_MODE = true, -- Set to false in production
}

-- SUPABASE CONFIGURATION
local SUPABASE_CONFIG = {
    URL = "https://nheljqlonhodbgpcfkww.supabase.co",
    ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5oZWxqcWxvbmhvZGJncGNma3d3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE5NzQ2MjQsImV4cCI6MjA2NzU1MDYyNH0.MtcA4YjKFWKsSPQMUG-SXOA1Ue1dml6v5Urdr0ISMnQ",
    SERVICE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5oZWxqcWxvbmhvZGJncGNma3d3Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MTk3NDYyNCwiZXhwIjoyMDY3NTUwNjI0fQ.0nspphu2HDg-irLhHQirwoJPHAUSMqEFEJvmq5FgK0g",
}

local KeyValidator = {}

-- Lua 5.1/5.2 compatible XOR function
local function xorByte(a, b)
    local result = 0
    local bitval = 1
    while a > 0 or b > 0 do
        if a % 2 ~= b % 2 then
            result = result + bitval
        end
        bitval = bitval * 2
        a = math.floor(a / 2)
        b = math.floor(b / 2)
    end
    return result
end

-- Debug and logging system
local DebugLogger = {
    logs = {},
    maxLogs = 100,
}

function DebugLogger:log(eventType, message, data)
    if not SECURITY_CONFIG.DEBUG_MODE then return end
    
    local logEntry = {
        timestamp = os.time(),
        eventType = eventType,
        message = message,
        data = data or {},
    }
    
    table.insert(self.logs, logEntry)
    
    -- Keep only last maxLogs entries
    if #self.logs > self.maxLogs then
        table.remove(self.logs, 1)
    end
    
    -- Print to console
    print(string.format("[DEBUG] [%s] %s", eventType, message))
    if data then
        local HttpService = game:GetService("HttpService")
        local success, jsonData = pcall(function()
            return HttpService:JSONEncode(data)
        end)
        if success then
            print("  Data: " .. jsonData)
        end
    end
    
    -- Send to database (async)
    pcall(function()
        self:sendToDatabase(logEntry)
    end)
end

function DebugLogger:sendToDatabase(logEntry)
    local headers = createSecureHeaders()
    local payload = {
        event_type = logEntry.eventType,
        message = logEntry.message,
        data = logEntry.data,
    }
    
    pcall(function()
        local HttpService = game:GetService("HttpService")
        game:HttpPost(
            SUPABASE_CONFIG.URL .. "/rest/v1/debug_logs",
            HttpService:JSONEncode(payload),
            Enum.HttpContentType.ApplicationJson,
            headers
        )
    end)
end

function DebugLogger:getLogs()
    return self.logs
end

function DebugLogger:clearLogs()
    self.logs = {}
end

-- System state with enhanced tracking
local SystemState = {
    initialized = false,
    setupAllowed = false,
    validationAllowed = false,
    securityLevel = 0,
    lastSecurityCheck = 0,
    connectionStatus = "unknown",
    lastConnectionTest = 0,
    errorCount = 0,
    successCount = 0,
}

-- Cache system with enhanced security
local SecureCache = {
    settings = {},
    userStatus = {},
    notifications = {},
    lastUpdate = 0,
    cacheSignature = "",
    connectionHealth = {},
}

-- Protected flags with validation
local ProtectedFlags = {
    isPremium = false,
    isBanned = false,
    isValidated = false,
    keylessMode = false,
    hwidCheck = true,
    maintenanceMode = false,
    setupComplete = false,
}

-- Enhanced security utilities
local function generateSecureHash(data)
    local hash = 0
    for i = 1, #data do
        hash = ((hash * 31) + string.byte(data, i)) % 2147483647
    end
    return tostring(hash)
end

-- Lua 5.1/5.2 compatible XOR encryption
local function xorEncrypt(data, key)
    local result = {}
    local keyLen = #key
    for i = 1, #data do
        local char = string.byte(data, i)
        local keyChar = string.byte(key, ((i - 1) % keyLen) + 1)
        table.insert(result, string.char(xorByte(char, keyChar)))
    end
    return table.concat(result)
end

local function base64Encode(data)
    local chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    local result = ''
    
    for i = 1, #data, 3 do
        local a, b, c = string.byte(data, i, i + 2)
        b = b or 0
        c = c or 0
        
        local bitmap = a * 65536 + b * 256 + c
        
        for j = 18, 0, -6 do
            local index = math.floor(bitmap / math.pow(2, j)) % 64 + 1
            result = result .. chars:sub(index, index)
        end
    end
    
    local padding_length = (3 - #data % 3) % 3
    result = result:sub(1, #result - padding_length) .. string.rep('=', padding_length)
    
    return result
end

-- Create ultra-secure headers with debug info
function createSecureHeaders()
    local timestamp = tostring(os.time())
    local nonce = tostring(math.random(100000, 999999))
    
    DebugLogger:log("SECURITY", "Creating secure headers", {
        timestamp = timestamp,
        nonce = nonce,
        securityLevel = SystemState.securityLevel
    })
    
    -- Multi-layer encryption
    local payload = SECURITY_CONFIG.MASTER_TOKEN .. "|" .. timestamp .. "|" .. nonce
    local encrypted1 = xorEncrypt(payload, SECURITY_CONFIG.PRIMARY_XOR_KEY)
    local encrypted2 = xorEncrypt(encrypted1, SECURITY_CONFIG.SECONDARY_XOR_KEY)
    local signature = base64Encode(encrypted2)
    
    -- API validation
    local apiHash = generateSecureHash(SECURITY_CONFIG.API_VALIDATION_HASH .. timestamp)
    
    return {
        ["Content-Type"] = "application/json",
        ["Authorization"] = "Bearer " .. SUPABASE_CONFIG.ANON_KEY,
        ["apikey"] = SUPABASE_CONFIG.ANON_KEY,
        ["X-Master-Token"] = SECURITY_CONFIG.MASTER_TOKEN,
        ["X-Signature"] = signature,
        ["X-Timestamp"] = timestamp,
        ["X-Nonce"] = nonce,
        ["X-Session"] = SECURITY_CONFIG.SESSION_TOKEN,
        ["X-API-Hash"] = apiHash,
        ["X-Security-Level"] = tostring(SystemState.securityLevel),
        ["Prefer"] = "return=minimal",
    }
end

-- Enhanced connection testing
local function testDatabaseConnection()
    DebugLogger:log("CONNECTION", "Testing database connection")
    
    local currentTime = os.time()
    if currentTime - SystemState.lastConnectionTest < 30 then
        DebugLogger:log("CONNECTION", "Connection test skipped (rate limited)")
        return SystemState.connectionStatus == "healthy"
    end
    
    SystemState.lastConnectionTest = currentTime
    
    local headers = createSecureHeaders()
    local testUrl = SUPABASE_CONFIG.URL .. "/rest/v1/system_settings?limit=1"
    
    local success, response = pcall(function()
        return game:HttpGet(testUrl, true)
    end)
    
    if success then
        local HttpService = game:GetService("HttpService")
        local parseSuccess, data = pcall(function()
            return HttpService:JSONDecode(response)
        end)
        
        if parseSuccess and type(data) == "table" then
            SystemState.connectionStatus = "healthy"
            SystemState.successCount = SystemState.successCount + 1
            DebugLogger:log("CONNECTION", "Database connection successful", {
                responseLength = #response,
                dataType = type(data),
                successCount = SystemState.successCount
            })
            return true
        else
            SystemState.connectionStatus = "parse_error"
            SystemState.errorCount = SystemState.errorCount + 1
            DebugLogger:log("CONNECTION", "Database response parse failed", {
                response = response:sub(1, 200),
                errorCount = SystemState.errorCount
            })
            return false
        end
    else
        SystemState.connectionStatus = "network_error"
        SystemState.errorCount = SystemState.errorCount + 1
        DebugLogger:log("CONNECTION", "Database connection failed", {
            error = tostring(response),
            errorCount = SystemState.errorCount
        })
        return false
    end
end

-- Get system information with enhanced validation
local function getSystemInfo()
    DebugLogger:log("SYSTEM", "Getting system information")
    
    local Players = game:GetService("Players")
    local RbxAnalyticsService = game:GetService("RbxAnalyticsService")
    local player = Players.LocalPlayer
    
    if not player then
        DebugLogger:log("SYSTEM", "No local player found")
        return nil
    end
    
    local hwid = ""
    local hwidSuccess = pcall(function()
        hwid = RbxAnalyticsService:GetClientId()
    end)
    
    if not hwidSuccess or hwid == "" then
        hwid = "UNKNOWN_" .. tostring(math.random(100000, 999999))
        DebugLogger:log("SYSTEM", "HWID generation fallback used", { hwid = hwid })
    else
        DebugLogger:log("SYSTEM", "HWID obtained successfully", { hwidLength = #hwid })
    end
    
    local executor = "Unknown"
    pcall(function()
        if identifyexecutor then
            executor = identifyexecutor()
        elseif getexecutorname then
            executor = getexecutorname()
        end
    end)
    
    local accountAge = player.AccountAge
    local ageString = ""
    if accountAge >= 365 then
        ageString = math.floor(accountAge / 365) .. "y"
    else
        ageString = accountAge .. "d"
    end
    
    local systemInfo = {
        username = player.Name,
        displayName = player.DisplayName,
        accountAge = ageString,
        hwid = hwid,
        executor = executor,
        userId = tostring(player.UserId),
    }
    
    DebugLogger:log("SYSTEM", "System information collected", systemInfo)
    return systemInfo
end

-- Enhanced security check
local function performSecurityCheck()
    local currentTime = os.time()
    
    -- Rate limiting
    if currentTime - SystemState.lastSecurityCheck < 5 then
        DebugLogger:log("SECURITY", "Security check rate limited")
        return false
    end
    
    SystemState.lastSecurityCheck = currentTime
    
    -- Validate critical tokens
    if SECURITY_CONFIG.MASTER_TOKEN == "" or SECURITY_CONFIG.SIGNATURE_KEY == "" then
        DebugLogger:log("SECURITY", "Critical security tokens missing")
        return false
    end
    
    -- Check system integrity
    if not game:GetService("Players").LocalPlayer then
        DebugLogger:log("SECURITY", "System integrity check failed - no local player")
        return false
    end
    
    -- Test database connection
    if not testDatabaseConnection() then
        DebugLogger:log("SECURITY", "Security check failed - database connection issue")
        return false
    end
    
    SystemState.securityLevel = SystemState.securityLevel + 1
    DebugLogger:log("SECURITY", "Security check passed", { securityLevel = SystemState.securityLevel })
    return true
end

-- Load notifications with enhanced error handling
local function loadNotifications()
    DebugLogger:log("NOTIFICATIONS", "Loading notifications from database")
    
    if not testDatabaseConnection() then
        DebugLogger:log("NOTIFICATIONS", "Cannot load notifications - connection failed")
        return false
    end
    
    local headers = createSecureHeaders()
    local success, response = pcall(function()
        return game:HttpGet(SUPABASE_CONFIG.URL .. "/rest/v1/system_notifications?is_active=eq.true", true)
    end)
    
    if success then
        local HttpService = game:GetService("HttpService")
        local parseSuccess, data = pcall(function()
            return HttpService:JSONDecode(response)
        end)
        
        if parseSuccess and type(data) == "table" then
            SecureCache.notifications = {}
            
            for _, notification in pairs(data) do
                SecureCache.notifications[notification.event_type] = {
                    title = notification.title,
                    message = notification.message,
                    icon = notification.icon,
                    color = notification.color,
                }
            end
            
            DebugLogger:log("NOTIFICATIONS", "Notifications loaded successfully", {
                count = #data
            })
            return true
        else
            DebugLogger:log("NOTIFICATIONS", "Failed to parse notifications response", {
                response = response:sub(1, 200)
            })
            return false
        end
    else
        DebugLogger:log("NOTIFICATIONS", "Failed to fetch notifications", {
            error = tostring(response)
        })
        return false
    end
end

-- Get notification with fallback
local function getNotification(eventType)
    if SecureCache.notifications[eventType] then
        return SecureCache.notifications[eventType]
    end
    
    DebugLogger:log("NOTIFICATIONS", "Using fallback notification", { eventType = eventType })
    
    -- Enhanced fallback notifications
    local fallbacks = {
        user_validated = {title = "Access Granted", message = "Welcome to Kanistay Hub!", icon = "✅", color = "green"},
        user_banned = {title = "Access Denied", message = "Your access has been restricted.", icon = "🚫", color = "red"},
        user_premium = {title = "Premium Access", message = "Premium features unlocked!", icon = "👑", color = "gold"},
        system_keyless = {title = "Keyless Mode", message = "No key required.", icon = "🔓", color = "blue"},
        system_disabled = {title = "System Disabled", message = "Under maintenance.", icon = "🔧", color = "orange"},
        key_invalid = {title = "Invalid Key", message = "Key is invalid or expired.", icon = "❌", color = "red"},
        key_used = {title = "Key In Use", message = "Key is being used elsewhere.", icon = "⚠️", color = "yellow"},
        network_error = {title = "Connection Error", message = "Network error occurred.", icon = "🌐", color = "red"},
        hwid_mismatch = {title = "Device Mismatch", message = "Key registered to different device.", icon = "🔒", color = "red"},
        setup_complete = {title = "Setup Complete", message = "System ready!", icon = "🚀", color = "green"},
    }
    
    return fallbacks[eventType] or {title = "System Message", message = "Unknown event", icon = "ℹ️", color = "blue"}
end

-- Load system settings with enhanced validation
local function loadSystemSettings()
    DebugLogger:log("SETTINGS", "Loading system settings")
    
    if not performSecurityCheck() then
        DebugLogger:log("SETTINGS", "Cannot load settings - security check failed")
        return false
    end
    
    local currentTime = os.time()
    
    -- Use cache if valid
    if currentTime - SecureCache.lastUpdate < 300 and SecureCache.settings.loaded then
        DebugLogger:log("SETTINGS", "Using cached settings")
        ProtectedFlags.keylessMode = SecureCache.settings.is_keyless or false
        ProtectedFlags.hwidCheck = SecureCache.settings.is_hwid_check or true
        ProtectedFlags.maintenanceMode = SecureCache.settings.maintenance_mode or false
        return true
    end
    
    local headers = createSecureHeaders()
    local success, response = pcall(function()
        return game:HttpGet(SUPABASE_CONFIG.URL .. "/rest/v1/system_settings", true)
    end)
    
    if success then
        local HttpService = game:GetService("HttpService")
        local parseSuccess, data = pcall(function()
            return HttpService:JSONDecode(response)
        end)
        
        if parseSuccess and type(data) == "table" then
            SecureCache.settings = {}
            
            for _, setting in pairs(data) do
                SecureCache.settings[setting.setting_key] = setting.setting_value
            end
            
            SecureCache.settings.loaded = true
            SecureCache.lastUpdate = currentTime
            SecureCache.cacheSignature = generateSecureHash(response)
            
            ProtectedFlags.keylessMode = SecureCache.settings.is_keyless or false
            ProtectedFlags.hwidCheck = SecureCache.settings.is_hwid_check or true
            ProtectedFlags.maintenanceMode = SecureCache.settings.maintenance_mode or false
            
            DebugLogger:log("SETTINGS", "Settings loaded successfully", {
                keylessMode = ProtectedFlags.keylessMode,
                hwidCheck = ProtectedFlags.hwidCheck,
                maintenanceMode = ProtectedFlags.maintenanceMode
            })
            return true
        else
            DebugLogger:log("SETTINGS", "Failed to parse settings response", {
                response = response:sub(1, 200)
            })
            return false
        end
    else
        DebugLogger:log("SETTINGS", "Failed to fetch settings", {
            error = tostring(response)
        })
        return false
    end
end

-- Check HWID status with enhanced validation
local function checkHWIDStatus(hwid)
    DebugLogger:log("HWID_CHECK", "Checking HWID status", { hwid = hwid:sub(1, 8) .. "..." })
    
    if not performSecurityCheck() then
        DebugLogger:log("HWID_CHECK", "HWID check failed - security check failed")
        return false, false, "Security check failed", ""
    end
    
    -- Check cache first
    local cacheKey = generateSecureHash(hwid .. SECURITY_CONFIG.SESSION_TOKEN)
    if SecureCache.userStatus[cacheKey] and os.time() - SecureCache.userStatus[cacheKey].timestamp < 300 then
        local status = SecureCache.userStatus[cacheKey]
        DebugLogger:log("HWID_CHECK", "Using cached HWID status", {
            isPremium = status.isPremium,
            isBanned = status.isBanned
        })
        return status.isPremium, status.isBanned, status.note, status.timeRemaining
    end
    
    local headers = createSecureHeaders()
    local success, response = pcall(function()
        return game:HttpGet(SUPABASE_CONFIG.URL .. "/rest/v1/advanced_keys?hwid=eq." .. hwid, true)
    end)
    
    if success then
        local HttpService = game:GetService("HttpService")
        local parseSuccess, data = pcall(function()
            return HttpService:JSONDecode(response)
        end)
        
        if parseSuccess and type(data) == "table" then
            if #data > 0 then
                local hwidData = data[1]
                local isPremium = hwidData.is_premium
                local isBanned = not isPremium
                local note = hwidData.note or ""
                local timeRemaining = hwidData.time_remaining or "Lifetime"
                
                -- Cache with security
                SecureCache.userStatus[cacheKey] = {
                    isPremium = isPremium,
                    isBanned = isBanned,
                    note = note,
                    timeRemaining = timeRemaining,
                    timestamp = os.time()
                }
                
                DebugLogger:log("HWID_CHECK", "HWID status found in database", {
                    isPremium = isPremium,
                    isBanned = isBanned,
                    timeRemaining = timeRemaining
                })
                
                return isPremium, isBanned, note, timeRemaining
            else
                DebugLogger:log("HWID_CHECK", "HWID not found in database")
            end
        else
            DebugLogger:log("HWID_CHECK", "Failed to parse HWID response", {
                response = response:sub(1, 200)
            })
        end
    else
        DebugLogger:log("HWID_CHECK", "Failed to fetch HWID data", {
            error = tostring(response)
        })
    end
    
    -- Cache negative result
    SecureCache.userStatus[cacheKey] = {
        isPremium = false,
        isBanned = false,
        note = "",
        timeRemaining = "",
        timestamp = os.time()
    }
    
    return false, false, "", ""
end

-- Enhanced key validation with comprehensive logging
local function validateKeyInDatabase(keyValue, systemInfo)
    DebugLogger:log("KEY_VALIDATION", "Starting key validation", {
        keyValue = keyValue:sub(1, 8) .. "...",
        username = systemInfo.username,
        hwid = systemInfo.hwid:sub(1, 8) .. "..."
    })
    
    if not SystemState.validationAllowed then
        DebugLogger:log("KEY_VALIDATION", "Validation not authorized")
        return false, "Validation not authorized"
    end
    
    local headers = createSecureHeaders()
    
    local success, response = pcall(function()
        return game:HttpGet(SUPABASE_CONFIG.URL .. "/rest/v1/normal_keys?key_value=eq." .. keyValue, true)
    end)
    
    if not success then
        DebugLogger:log("KEY_VALIDATION", "Network error during key validation", {
            error = tostring(response)
        })
        return false, "network_error"
    end
    
    local HttpService = game:GetService("HttpService")
    local parseSuccess, data = pcall(function()
        return HttpService:JSONDecode(response)
    end)
    
    if not parseSuccess then
        DebugLogger:log("KEY_VALIDATION", "Failed to parse key validation response", {
            response = response:sub(1, 200)
        })
        return false, "network_error"
    end
    
    if #data == 0 then
        DebugLogger:log("KEY_VALIDATION", "Key not found in database")
        return false, "key_invalid"
    end
    
    local keyData = data[1]
    DebugLogger:log("KEY_VALIDATION", "Key found in database", {
        status = keyData.status,
        hwid = keyData.hwid and (keyData.hwid:sub(1, 8) .. "...") or "none"
    })
    
    if keyData.status == "unused" then
        -- First time use
        local updateData = {
            status = "active",
            user_id = systemInfo.username,
            display_name = systemInfo.displayName,
            hwid = systemInfo.hwid,
            executor = systemInfo.executor,
            used_at = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }
        
        local updateSuccess = pcall(function()
            return game:HttpPost(
                SUPABASE_CONFIG.URL .. "/rest/v1/normal_keys?id=eq." .. keyData.id,
                HttpService:JSONEncode(updateData),
                Enum.HttpContentType.ApplicationJson,
                headers
            )
        end)
        
        if updateSuccess then
            DebugLogger:log("KEY_VALIDATION", "Key activated successfully")
            return true, "user_validated"
        else
            DebugLogger:log("KEY_VALIDATION", "Failed to activate key")
            return false, "network_error"
        end
        
    elseif keyData.status == "active" then
        if ProtectedFlags.hwidCheck then
            if keyData.hwid == systemInfo.hwid then
                -- Same user - update info
                local updateData = {
                    user_id = systemInfo.username,
                    display_name = systemInfo.displayName,
                    executor = systemInfo.executor,
                    used_at = os.date("!%Y-%m-%dT%H:%M:%SZ")
                }
                
                pcall(function()
                    game:HttpPost(
                        SUPABASE_CONFIG.URL .. "/rest/v1/normal_keys?id=eq." .. keyData.id,
                        HttpService:JSONEncode(updateData),
                        Enum.HttpContentType.ApplicationJson,
                        headers
                    )
                end)
                
                DebugLogger:log("KEY_VALIDATION", "Key validated for same HWID")
                return true, "user_validated"
            else
                DebugLogger:log("KEY_VALIDATION", "HWID mismatch detected", {
                    expectedHwid = keyData.hwid:sub(1, 8) .. "...",
                    actualHwid = systemInfo.hwid:sub(1, 8) .. "..."
                })
                return false, "hwid_mismatch"
            end
        else
            -- HWID check disabled
            local updateData = {
                user_id = systemInfo.username,
                display_name = systemInfo.displayName,
                hwid = systemInfo.hwid,
                executor = systemInfo.executor,
                used_at = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }
            
            pcall(function()
                game:HttpPost(
                    SUPABASE_CONFIG.URL .. "/rest/v1/normal_keys?id=eq." .. keyData.id,
                    HttpService:JSONEncode(updateData),
                    Enum.HttpContentType.ApplicationJson,
                    headers
                )
            end)
            
            DebugLogger:log("KEY_VALIDATION", "Key validated (HWID check disabled)")
            return true, "user_validated"
        end
    else
        DebugLogger:log("KEY_VALIDATION", "Key has invalid status", { status = keyData.status })
        return false, "key_invalid"
    end
end

-- Main validation function with comprehensive error handling
function KeyValidator.ValidateKey(keyValue, callback)
    DebugLogger:log("MAIN_VALIDATION", "Starting main validation process")
    
    if not SystemState.validationAllowed then
        DebugLogger:log("MAIN_VALIDATION", "Validation not allowed")
        local notification = getNotification("network_error")
        callback(false, notification)
        return
    end
    
    if not loadSystemSettings() then
        DebugLogger:log("MAIN_VALIDATION", "Failed to load system settings")
        local notification = getNotification("network_error")
        callback(false, notification)
        return
    end
    
    if ProtectedFlags.maintenanceMode then
        DebugLogger:log("MAIN_VALIDATION", "System in maintenance mode")
        local notification = getNotification("system_disabled")
        callback(false, notification)
        return
    end
    
    local systemInfo = getSystemInfo()
    if not systemInfo then
        DebugLogger:log("MAIN_VALIDATION", "Failed to get system information")
        local notification = getNotification("network_error")
        callback(false, notification)
        return
    end
    
    local isPremium, isBanned, note, timeRemaining = checkHWIDStatus(systemInfo.hwid)
    
    ProtectedFlags.isPremium = isPremium
    ProtectedFlags.isBanned = isBanned
    
    if isBanned then
        DebugLogger:log("MAIN_VALIDATION", "User is banned")
        local notification = getNotification("user_banned")
        notification.message = note
        callback(false, notification)
        return
    end
    
    if isPremium then
        DebugLogger:log("MAIN_VALIDATION", "User has premium access")
        ProtectedFlags.isValidated = true
        local notification = getNotification("user_premium")
        notification.message = "Premium access (" .. timeRemaining .. ")"
        callback(true, notification)
        return
    end
    
    if ProtectedFlags.keylessMode then
        DebugLogger:log("MAIN_VALIDATION", "System in keyless mode")
        ProtectedFlags.isValidated = true
        local notification = getNotification("system_keyless")
        callback(true, notification)
        return
    end
    
    if not keyValue or keyValue == "" then
        DebugLogger:log("MAIN_VALIDATION", "No key provided")
        local notification = getNotification("key_invalid")
        notification.message = "Please enter a key"
        callback(false, notification)
        return
    end
    
    local isValid, eventType = validateKeyInDatabase(keyValue, systemInfo)
    local notification = getNotification(eventType)
    
    if isValid then
        ProtectedFlags.isValidated = true
        DebugLogger:log("MAIN_VALIDATION", "Validation successful")
    else
        DebugLogger:log("MAIN_VALIDATION", "Validation failed", { eventType = eventType })
    end
    
    callback(isValid, notification)
end

-- Enhanced setup function
function KeyValidator.Setup(callback)
    DebugLogger:log("SETUP", "Starting setup process")
    
    if not performSecurityCheck() then
        DebugLogger:log("SETUP", "Setup failed - security check failed")
        local notification = getNotification("network_error")
        callback(false, "error", notification)
        return
    end
    
    -- Load notifications first
    loadNotifications()
    
    if not loadSystemSettings() then
        DebugLogger:log("SETUP", "Setup failed - could not load settings")
        local notification = getNotification("network_error")
        callback(false, "error", notification)
        return
    end
    
    if ProtectedFlags.maintenanceMode then
        DebugLogger:log("SETUP", "Setup blocked - maintenance mode")
        local notification = getNotification("system_disabled")
        callback(false, "maintenance", notification)
        return
    end
    
    local systemInfo = getSystemInfo()
    if not systemInfo then
        DebugLogger:log("SETUP", "Setup failed - no system info")
        local notification = getNotification("network_error")
        callback(false, "error", notification)
        return
    end
    
    local isPremium, isBanned, note, timeRemaining = checkHWIDStatus(systemInfo.hwid)
    
    ProtectedFlags.isPremium = isPremium
    ProtectedFlags.isBanned = isBanned
    
    if isBanned then
        DebugLogger:log("SETUP", "Setup blocked - user banned")
        local notification = getNotification("user_banned")
        notification.message = note
        callback(false, "banned", notification)
        return
    end
    
    if isPremium then
        DebugLogger:log("SETUP", "Setup complete - premium user")
        ProtectedFlags.isValidated = true
        SystemState.setupAllowed = true
        SystemState.validationAllowed = true
        ProtectedFlags.setupComplete = true
        
        local notification = getNotification("user_premium")
        notification.message = "Premium access (" .. timeRemaining .. ")"
        callback(true, "premium", notification)
        return
    end
    
    if ProtectedFlags.keylessMode then
        DebugLogger:log("SETUP", "Setup complete - keyless mode")
        ProtectedFlags.isValidated = true
        SystemState.setupAllowed = true
        SystemState.validationAllowed = true
        ProtectedFlags.setupComplete = true
        
        local notification = getNotification("system_keyless")
        callback(true, "keyless", notification)
        return
    end
    
    -- Normal user - allow validation
    DebugLogger:log("SETUP", "Setup complete - normal user")
    SystemState.validationAllowed = true
    local notification = getNotification("setup_complete")
    notification.message = "Key validation required"
    callback(true, "normal", notification)
end

-- Debug functions
function KeyValidator.GetDebugLogs()
    return DebugLogger:getLogs()
end

function KeyValidator.ClearDebugLogs()
    DebugLogger:clearLogs()
end

function KeyValidator.GetSystemStatus()
    return {
        systemState = SystemState,
        protectedFlags = ProtectedFlags,
        connectionStatus = SystemState.connectionStatus,
        errorCount = SystemState.errorCount,
        successCount = SystemState.successCount,
        cacheStatus = {
            settingsLoaded = SecureCache.settings.loaded or false,
            lastUpdate = SecureCache.lastUpdate,
            notificationCount = 0,
        }
    }
end

-- Get protected flags (read-only)
function KeyValidator.GetFlags()
    return {
        isPremium = ProtectedFlags.isPremium,
        isBanned = ProtectedFlags.isBanned,
        isValidated = ProtectedFlags.isValidated,
        keylessMode = ProtectedFlags.keylessMode,
        hwidCheck = ProtectedFlags.hwidCheck,
        maintenanceMode = ProtectedFlags.maintenanceMode,
        setupComplete = ProtectedFlags.setupComplete,
    }
end

-- Get system state (read-only)
function KeyValidator.GetSystemState()
    return {
        initialized = SystemState.initialized,
        setupAllowed = SystemState.setupAllowed,
        validationAllowed = SystemState.validationAllowed,
        securityLevel = SystemState.securityLevel,
        connectionStatus = SystemState.connectionStatus,
    }
end

-- Get link for key generation
function KeyValidator.GetLink()
    return "https://kanistay.vercel.app/"
end

-- Initialize validator with enhanced security and debugging
function KeyValidator.Init()
    if SystemState.initialized then
        DebugLogger:log("INIT", "Validator already initialized")
        return false
    end
    
    SystemState.initialized = true
    SystemState.securityLevel = 1
    
    DebugLogger:log("INIT", "Kanistay Key Validator v4.0 initialized", {
        debugMode = SECURITY_CONFIG.DEBUG_MODE,
        sessionToken = SECURITY_CONFIG.SESSION_TOKEN,
        securityLevel = SystemState.securityLevel
    })
    
    print("╔══════════════════════════════════════════════════════════════════════════════╗")
    print("║                        KANISTAY KEY VALIDATOR v4.0                           ║")
    print("║                    ENHANCED DEBUG & SECURITY SYSTEM                          ║")
    print("║                        COMPATIBLE WITH LUA 5.1/5.2                          ║")
    print("╚══════════════════════════════════════════════════════════════════════════════╝")
    print("🔒 Security Features: Multi-Layer Encryption, Enhanced Validation, Debug Logging")
    print("🚀 Session Token: " .. SECURITY_CONFIG.SESSION_TOKEN)
    print("🐛 Debug Mode: " .. (SECURITY_CONFIG.DEBUG_MODE and "ENABLED" or "DISABLED"))
    print("⚡ Lua Version: Compatible with 5.1/5.2")
    
    -- Test initial connection
    testDatabaseConnection()
    
    return true
end

return KeyValidator
