--[[
  Key Validator v2.1
  Kanistay sistemleri için gelişmiş güvenlik özellikli key doğrulama aracı
  - Saved Key özelliği ile API kullanımını azaltma
]]

-- KeyValidator modülü oluştur
local KeyValidator = {}

-- Güvenli JSON kodlama
local function safeJSONEncode(data)
    local httpService = game:GetService("HttpService")
    local success, result = pcall(function()
        return httpService:JSONEncode(data)
    end)
    
    if success then
        return result
    else
        print("[KeyValidator] JSON kodlama hatası:", result)
        return "{}"
    end
end

-- Güvenli servis erişimi
local function safeGetService(serviceName)
    local success, service = pcall(function()
        return game:GetService(serviceName)
    end)
    
    if success and service then
        return service
    end
    
    print("[KeyValidator] Servis bulunamadı:", serviceName)
    return {}  -- Boş tablo döndür (GetChildren çağrıldığında hata vermemesi için)
end

-- Bit işlemleri için güvenli fonksiyonlar
local bit = {}

-- Bit kütüphanelerinin varlığını kontrol et
local hasBit32 = false
local hasBit = false

pcall(function() hasBit32 = bit32 ~= nil end)
pcall(function() hasBit = bit ~= nil end)

-- XOR işlemi için güvenli fonksiyon
bit.bxor = function(a, b)
    -- Bit32 kütüphanesi (Lua 5.2+)
    if hasBit32 and bit32 and bit32.bxor then
        return bit32.bxor(a, b)
    -- Bit kütüphanesi (LuaJIT)
    elseif hasBit and _G.bit and _G.bit.bxor then
        return _G.bit.bxor(a, b)
    -- Basit XOR implementasyonu
    else
        local r = 0
        for i = 0, 31 do
            local x = (a % 2) + (b % 2)
            if x == 1 then -- XOR: 1 if bits are different
                r = r + 2^i
            end
            a = math.floor(a / 2)
            b = math.floor(b / 2)
            if a == 0 and b == 0 then break end
        end
        return r
    end
end

-- Band işlemi için güvenli fonksiyon
bit.band = function(a, b)
    -- Bit32 kütüphanesi (Lua 5.2+)
    if hasBit32 and bit32 and bit32.band then
        return bit32.band(a, b)
    -- Bit kütüphanesi (LuaJIT)
    elseif hasBit and _G.bit and _G.bit.band then
        return _G.bit.band(a, b)
    -- Basit AND implementasyonu
    else
        local r = 0
        for i = 0, 31 do
            if a % 2 == 1 and b % 2 == 1 then
                r = r + 2^i
            end
            a = math.floor(a / 2)
            b = math.floor(b / 2)
            if a == 0 or b == 0 then break end
        end
        return r
    end
end

-- Left shift işlemi için güvenli fonksiyon
bit.lshift = function(a, b)
    -- Bit32 kütüphanesi (Lua 5.2+)
    if hasBit32 and bit32 and bit32.lshift then
        return bit32.lshift(a, b)
    -- Bit kütüphanesi (LuaJIT)
    elseif hasBit and _G.bit and _G.bit.lshift then
        return _G.bit.lshift(a, b)
    -- Basit left shift implementasyonu
    else
        return a * (2 ^ b)
    end
end

-- Right shift işlemi için güvenli fonksiyon
bit.rshift = function(a, b)
    -- Bit32 kütüphanesi (Lua 5.2+)
    if hasBit32 and bit32 and bit32.rshift then
        return bit32.rshift(a, b)
    -- Bit kütüphanesi (LuaJIT)
    elseif hasBit and _G.bit and _G.bit.rshift then
        return _G.bit.rshift(a, b)
    -- Basit right shift implementasyonu
    else
        return math.floor(a / (2 ^ b))
    end
end

-- Bor işlemi için güvenli fonksiyon
bit.bor = function(a, b)
    -- Bit32 kütüphanesi (Lua 5.2+)
    if hasBit32 and bit32 and bit32.bor then
        return bit32.bor(a, b)
    -- Bit kütüphanesi (LuaJIT)
    elseif hasBit and _G.bit and _G.bit.bor then
        return _G.bit.bor(a, b)
    -- Basit OR implementasyonu
    else
        local r = 0
        for i = 0, 31 do
            if a % 2 == 1 or b % 2 == 1 then
                r = r + 2^i
            end
            a = math.floor(a / 2)
            b = math.floor(b / 2)
            if a == 0 and b == 0 then break end
        end
        return r
    end
end

-- Yapılandırma
KeyValidator.Config = {
    ApiUrl = "https://kanistay.workers.dev/api/validate",
    Debug = false, -- Debug modunu aktif et
    -- Güvenlik anahtarı - API ile paylaşılan gizli anahtar
    SecurityKey = "K4n1st4y_S3cur1ty_K3y_2025_v2",
    -- İstek aralığı (saniye) - spam koruması için
    RequestInterval = 5,
    -- Son istek zamanı
    LastRequestTime = 0,
    -- Saved key süresi (saniye) - 12 saat
    SavedKeyDuration = 12 * 60 * 60,
    -- Saved key şifreleme anahtarı - extra güvenlik için
    SavedKeyEncryptionKey = "S4v3d_K3y_3ncrypt10n_K3y_2025",
    -- HTTP istek zaman aşımı (saniye)
    HttpTimeout = 30,
    -- API isteği başarısız olduğunda tekrar deneme sayısı
    RetryCount = 3,
    -- API isteği başarısız olduğunda tekrar denemeler arasındaki süre (saniye)
    RetryDelay = 2
}

-- Yardımcı fonksiyonlar
function KeyValidator:Log(...)
    if self.Config.Debug then
        print("[KeyValidator]", ...)
    end
end

-- Daha detaylı log fonksiyonu
function KeyValidator:DetailedLog(category, ...)
    if self.Config.Debug then
        print("[KeyValidator][" .. category .. "]", ...)
    end
end

local PROTOCOL_SALT = "KANISTAY2024v5"

function KeyValidator:ObfuscateString(str)
    if not str then return "" end
    local encKey = self.Config.SecurityKey .. PROTOCOL_SALT
    local keyLen = #encKey
    local result = ""
    for i = 1, #str do
        local charCode = string.byte(str, i)
        local keyChar = string.byte(encKey, ((i - 1) % keyLen) + 1)
        local encodedChar = bit.bxor(charCode, keyChar)
        result = result .. string.char(encodedChar)
    end
    local encodedResult = "HEX:"
    for i = 1, #result do
        encodedResult = encodedResult .. string.format("%02x", string.byte(result, i))
    end
    return encodedResult
end

function KeyValidator:DeobfuscateString(str)
    if not str then return "" end
    local encKey = self.Config.SecurityKey .. PROTOCOL_SALT
    local keyLen = #encKey
    local decodedStr = str
    if string.sub(str, 1, 4) == "HEX:" then
        local hexStr = string.sub(str, 5)
        local bytes = {}
        for i = 1, #hexStr, 2 do
            local hex = string.sub(hexStr, i, i+1)
            table.insert(bytes, string.char(tonumber(hex, 16)))
        end
        decodedStr = table.concat(bytes)
    end
    local result = ""
    for i = 1, #decodedStr do
        local encodedChar = string.byte(decodedStr, i)
        local keyChar = string.byte(encKey, ((i - 1) % keyLen) + 1)
        local decodedChar = bit.bxor(encodedChar, keyChar)
        result = result .. string.char(decodedChar)
    end
    return result
end

function KeyValidator:GenerateSignature(data, timestamp)
    local httpService = safeGetService("HttpService")
    local dataStr = httpService:JSONEncode(data)
    local signatureBase = dataStr .. self.Config.SecurityKey .. timestamp .. PROTOCOL_SALT
    local hash = 0
    for i = 1, #signatureBase do
        hash = ((hash * 31) + string.byte(signatureBase, i)) % 0x100000000
    end
    return string.format("%x", hash)
end

-- Dosya işlemleri için güvenli fonksiyonlar
local fileSystem = {
    canWrite = false,
    canRead = false,
    canCheck = false
}

-- Dosya yazma ve okuma yeteneklerini kontrol et
do
    local success = false
    success, fileSystem.canWrite = pcall(function() return type(writefile) == "function" end)
    if not success then fileSystem.canWrite = false end
    
    success, fileSystem.canRead = pcall(function() return type(readfile) == "function" end)
    if not success then fileSystem.canRead = false end
    
    success, fileSystem.canCheck = pcall(function() return type(isfile) == "function" end)
    if not success then fileSystem.canCheck = false end
end

-- Saved key yönetimi
-- Kaydedilmiş anahtarları saklamak için tablo
KeyValidator.SavedKeys = {}

-- Saved key kaydetme
function KeyValidator:SaveKey(key, keyData)
    if not key or not keyData then return false end
    
    self:DetailedLog("SaveKey", "Anahtar kaydediliyor:", key)
    
    local timestamp = os.time()
    local expiresAt = timestamp + self.Config.SavedKeyDuration
    
    -- Kaydedilecek veri
    local savedData = {
        key = key,
        timestamp = timestamp,
        expires_at = expiresAt,
        data = keyData,
        checksum = self:GenerateSignature({key = key, timestamp = timestamp}, tostring(expiresAt)) -- Güvenlik için checksum ekle
    }
    
    -- Veriyi JSON'a dönüştür
    local httpService = safeGetService("HttpService")
    local success, jsonData = pcall(function()
        return httpService:JSONEncode(savedData)
    end)
    
    if not success then
        self:DetailedLog("SaveKey", "JSON kodlama hatası:", jsonData)
        return false
    end
    
    -- JSON verisini şifrele
    local encryptedData = self:ObfuscateString(jsonData)
    
    -- Önce memory'ye kaydet
    self.SavedKeys[key] = savedData
    self:DetailedLog("SaveKey", "Anahtar memory'ye kaydedildi")
    
    -- Dosya sistemine kaydet
    if fileSystem.canWrite then
        -- Dosya adını oluştur
        local fileName = "kanistay_key_" .. self:ObfuscateString(key, "FILE_NAME_KEY") .. ".dat"
        
        local success, result = pcall(function()
            writefile(fileName, encryptedData)
            return true
        end)
        
        if success and result then
            self:DetailedLog("SaveKey", "Anahtar dosyaya kaydedildi:", fileName)
            
            -- Doğrulama dosyası oluştur (manipülasyonu önlemek için)
            local verificationData = {
                key_hash = self:ObfuscateString(key, "VERIFICATION_KEY"),
                timestamp = timestamp,
                signature = self:GenerateSignature({key = key, timestamp = timestamp}, self.Config.SecurityKey)
            }
            
            local verificationFileName = "kanistay_verify_" .. self:ObfuscateString(key, "FILE_NAME_KEY") .. ".dat"
            
            pcall(function()
                local verificationJson = httpService:JSONEncode(verificationData)
                writefile(verificationFileName, verificationJson)
                self:DetailedLog("SaveKey", "Doğrulama dosyası oluşturuldu")
            end)
            
            return true
        else
            self:DetailedLog("SaveKey", "Dosya yazma hatası:", result)
        end
    else
        self:DetailedLog("SaveKey", "Dosya yazma yetkisi yok, sadece memory'ye kaydedildi")
    end
    
    return true
end

-- Kaydedilmiş anahtarı kontrol et
function KeyValidator:CheckSavedKey(key)
    if not key then return nil end
    
    self:DetailedLog("SavedKey", "Kaydedilmiş anahtar kontrol ediliyor:", key)
    
    -- Önce memory'de kontrol et
    if self.SavedKeys[key] then
        local savedData = self.SavedKeys[key]
        local currentTime = os.time()
        
        -- Süre kontrolü
        if savedData.expires_at and savedData.expires_at > currentTime then
            self:DetailedLog("SavedKey", "Memory'de geçerli anahtar bulundu, kalan süre:", savedData.expires_at - currentTime, "saniye")
            return savedData.data
        else
            self:DetailedLog("SavedKey", "Memory'deki anahtarın süresi dolmuş")
            -- Süresi dolmuş anahtarı temizle
            self.SavedKeys[key] = nil
        end
    end
    
    -- Dosya sisteminde kontrol et
    if not fileSystem.canRead or not fileSystem.canCheck then
        self:DetailedLog("SavedKey", "Dosya sistemi erişimi yok, kaydedilmiş anahtar kontrolü atlanıyor")
        return nil
    end
    
    -- Dosya adını oluştur
    local fileName = "kanistay_key_" .. self:ObfuscateString(key, "FILE_NAME_KEY") .. ".dat"
    
    -- Dosya var mı kontrol et
    local fileExists = false
    pcall(function()
        fileExists = isfile(fileName)
    end)
    
    if not fileExists then
        self:DetailedLog("SavedKey", "Kaydedilmiş anahtar dosyası bulunamadı:", fileName)
        return nil
    end
    
    -- Dosyayı oku
    local fileContent = nil
    local success, result = pcall(function()
        return readfile(fileName)
    end)
    
    if not success or not result then
        self:DetailedLog("SavedKey", "Dosya okuma hatası:", result)
        return nil
    end
    
    fileContent = result
    self:DetailedLog("SavedKey", "Dosya okundu, boyut:", #fileContent, "byte")
    
    -- Şifreli içeriği çöz
    local decryptedContent = self:DeobfuscateString(fileContent)
    
    -- JSON'a çevir
    local httpService = safeGetService("HttpService")
    local success, savedData = pcall(function()
        return httpService:JSONDecode(decryptedContent)
    end)
    
    if not success or not savedData then
        self:DetailedLog("SavedKey", "JSON ayrıştırma hatası:", savedData)
        return nil
    end
    
    -- Veri bütünlüğü kontrolü
    if not savedData.key or savedData.key ~= key or not savedData.expires_at or not savedData.timestamp or not savedData.checksum then
        self:DetailedLog("SavedKey", "Geçersiz veri formatı")
        return nil
    end
    
    -- Checksum kontrolü
    local expectedChecksum = self:GenerateSignature({key = key, timestamp = savedData.timestamp}, tostring(savedData.expires_at))
    if savedData.checksum ~= expectedChecksum then
        self:DetailedLog("SavedKey", "Checksum doğrulama hatası, manipülasyon tespit edildi")
        return nil
    end
    
    -- Süre kontrolü
    local currentTime = os.time()
    if savedData.expires_at <= currentTime then
        self:DetailedLog("SavedKey", "Anahtarın süresi dolmuş, son kullanma:", os.date("%Y-%m-%d %H:%M:%S", savedData.expires_at))
        
        -- Süresi dolmuş dosyayı sil
        pcall(function()
            delfile(fileName)
        end)
        
        return nil
    end
    
    -- Memory'ye kaydet
    self.SavedKeys[key] = savedData
    
    self:DetailedLog("SavedKey", "Geçerli kaydedilmiş anahtar bulundu, kalan süre:", savedData.expires_at - currentTime, "saniye")
    return savedData.data
end

-- HTTP isteği gönderme
function KeyValidator:HttpRequest(url, method, headers, body)
    self:Log("HTTP isteği hazırlanıyor:", url)
    self:DetailedLog("HTTPRequest", "URL:", url)
    self:DetailedLog("HTTPRequest", "Method:", method or "POST")
    
    -- Headers'ı yazdır
    if headers then
        local headerStr = ""
        for k, v in pairs(headers) do
            headerStr = headerStr .. k .. ": " .. v .. ", "
        end
        self:DetailedLog("HTTPRequest", "Headers:", headerStr)
    end
    
    -- Body'yi yazdır (ilk 200 karakter)
    if body then
        local bodyPreview = string.sub(body, 1, 200)
        if #body > 200 then bodyPreview = bodyPreview .. "..." end
        self:DetailedLog("HTTPRequest", "Body Preview:", bodyPreview)
    end
    
    -- İstek spam koruması
    local currentTime = os.time()
    if currentTime - self.Config.LastRequestTime < self.Config.RequestInterval then
        self:Log("İstek çok sık yapılıyor, lütfen bekleyin")
        return {
            Success = false,
            StatusCode = 429,
            Body = "Too many requests. Please wait before trying again."
        }
    end
    
    self.Config.LastRequestTime = currentTime
    
    local requestFn = nil
    local requestArgs = {
        Url = url,
        Method = method or "POST",
        Headers = headers or {},
        Body = body or ""
    }
    
    -- Timeout ekle (eğer destekleniyorsa)
    if self.Config.HttpTimeout then
        requestArgs.Timeout = self.Config.HttpTimeout
    end
    
    -- Debug modunda istek detaylarını göster
    if self.Config.Debug then
        self:DetailedLog("HTTPRequest", "URL:", url)
        self:DetailedLog("HTTPRequest", "Method:", method or "POST")
        self:DetailedLog("HTTPRequest", "Timeout:", self.Config.HttpTimeout or "varsayılan")
        
        if headers then
            local headerStr = ""
            for k, v in pairs(headers) do
                headerStr = headerStr .. k .. ": " .. v .. ", "
            end
            self:DetailedLog("HTTPRequest", "Headers:", headerStr)
        end
        
        self:DetailedLog("HTTPRequest", "Body Length:", body and #body or 0)
    end
    
    -- Farklı HTTP kütüphanelerini dene
    local hasSyn = false
    pcall(function() hasSyn = syn ~= nil end)
    
    local hasHttp = false
    pcall(function() hasHttp = http ~= nil end)
    
    local hasRequest = false
    pcall(function() hasRequest = type(request) == "function" end)
    
    if hasSyn and syn and syn.request then
        requestFn = syn.request
        self:Log("Synapse X HTTP API kullanılıyor")
    elseif hasHttp and http and http.request then
        requestFn = http.request
        self:Log("Standard HTTP API kullanılıyor")
    elseif hasRequest and request then
        requestFn = request
        self:Log("Generic request API kullanılıyor")
    elseif game then
        -- Roblox HttpService alternatif yöntem
        local httpService = safeGetService("HttpService")
        
        if httpService then
            requestFn = function(args)
                self:DetailedLog("HTTPRequest", "Roblox HttpService ile istek gönderiliyor")
                
                -- Roblox HttpService'in desteklediği özellikleri kontrol et
                local hasRequestAsync = false
                pcall(function() hasRequestAsync = type(httpService.RequestAsync) == "function" end)
                
                local success, result = pcall(function()
                    if hasRequestAsync then
                        -- RequestAsync methodu daha fazla kontrol sağlar
                        self:DetailedLog("HTTPRequest", "RequestAsync kullanılıyor")
                        return httpService:RequestAsync({
                            Url = args.Url,
                            Method = args.Method,
                            Headers = args.Headers,
                            Body = args.Body
                        })
                    elseif args.Method == "POST" then
                        -- RequestInternal kullanarak timeout ekle
                        if httpService.RequestInternal then
                            local options = {
                                Url = args.Url,
                                Method = "POST",
                                Headers = args.Headers,
                                Body = args.Body,
                                Timeout = args.Timeout or 30
                            }
                            self:DetailedLog("HTTPRequest", "RequestInternal kullanılıyor, timeout:", options.Timeout)
                            local response = httpService:RequestInternal(options)
                            return response
                        else
                            self:DetailedLog("HTTPRequest", "PostAsync kullanılıyor")
                            local response = httpService:PostAsync(args.Url, args.Body, Enum.HttpContentType.ApplicationJson, false, args.Headers)
                            self:DetailedLog("HTTPResponse", "PostAsync yanıtı alındı, uzunluk:", #response)
                            return {
                                Success = true,
                                StatusCode = 200,
                                Body = response
                            }
                        end
                    else
                        -- GET isteği için
                        if httpService.RequestInternal then
                            local options = {
                                Url = args.Url,
                                Method = "GET",
                                Headers = args.Headers,
                                Timeout = args.Timeout or 30
                            }
                            self:DetailedLog("HTTPRequest", "RequestInternal kullanılıyor, timeout:", options.Timeout)
                            local response = httpService:RequestInternal(options)
                            return response
                        else
                            self:DetailedLog("HTTPRequest", "GetAsync kullanılıyor")
                            local response = httpService:GetAsync(args.Url, false, args.Headers)
                            self:DetailedLog("HTTPResponse", "GetAsync yanıtı alındı, uzunluk:", #response)
                            return {
                                Success = true,
                                StatusCode = 200,
                                Body = response
                            }
                        end
                    end
                end)
                
                if success then
                    return result
                else
                    self:DetailedLog("HTTPError", "Roblox HttpService hatası:", result)
                    return {
                        Success = false,
                        StatusCode = 0,
                        Body = "Roblox HttpService hatası: " .. tostring(result)
                    }
                end
            end
            self:Log("Roblox HttpService kullanılıyor")
        else
            self:Log("HttpService bulunamadı")
            return {
                Success = false,
                StatusCode = 0,
                Body = "HttpService bulunamadı"
            }
        end
    else
        self:Log("HTTP kütüphanesi bulunamadı")
        return {
            Success = false,
            StatusCode = 0,
            Body = "HTTP kütüphanesi bulunamadı"
        }
    end
    
    -- İsteği gönder
    self:Log("HTTP isteği gönderiliyor...")
    local success, response = pcall(function()
        return requestFn(requestArgs)
    end)
    
    if not success then
        self:Log("HTTP isteği başarısız:", response)
        self:DetailedLog("HTTPError", "İstek hatası:", response)
        return {
            Success = false,
            StatusCode = 0,
            Body = "HTTP isteği başarısız: " .. tostring(response)
        }
    end
    
    if response.Success then
        self:Log("HTTP yanıtı alındı - Status:", response.StatusCode)
        
        -- Debug modunda yanıt içeriğini göster (ilk 500 karakter)
        if self.Config.Debug and response.Body then
            local previewBody = string.sub(response.Body, 1, 500)
            if #response.Body > 500 then
                previewBody = previewBody .. "..."
            end
            self:DetailedLog("HTTPResponse", "Body Preview:", previewBody)
        end
    else
        self:Log("HTTP isteği başarısız oldu - Status:", response.StatusCode or "bilinmiyor")
        if response.Body then
            self:DetailedLog("HTTPError", "Hata mesajı:", response.Body)
        end
    end
    
    return response
end

-- HWID alma
function KeyValidator:GetHWID()
    self:DetailedLog("HWID", "HWID alınıyor...")
    
    local hwid = nil
    
    -- RbxAnalyticsService ile HWID alma (en güvenilir yöntem)
    pcall(function()
        local rbxAnalytics = game:GetService("RbxAnalyticsService")
        hwid = rbxAnalytics:GetClientId()
        self:DetailedLog("HWID", "RbxAnalyticsService HWID alındı:", hwid)
    end)
    
    -- HWID kontrolü
    if not hwid or hwid == "" or hwid == "N/A" or hwid == "Unknown" then
        -- Alternatif olarak Synapse X yöntemi
        local hasSyn = false
        pcall(function() hasSyn = syn ~= nil end)
        
        if hasSyn and syn and syn.crypt and syn.crypt.hash then
            pcall(function()
                hwid = syn.crypt.hash("sha384", game:GetService("RbxAnalyticsService"):GetClientId())
                self:DetailedLog("HWID", "Synapse X HWID hash alındı")
            end)
        end
    end
    
    -- Hala HWID alınamadıysa son çare olarak sabit bir değer oluştur
    if not hwid or hwid == "" or hwid == "N/A" or hwid == "Unknown" then
        local httpService = safeGetService("HttpService")
        hwid = httpService:GenerateGUID(false)
        self:DetailedLog("HWID", "Rastgele GUID HWID oluşturuldu")
    end
    
    -- HWID'yi kısalt (çok uzun olabilir)
    if hwid and #hwid > 50 then
        hwid = string.sub(hwid, 1, 50)
    end
    
    self:DetailedLog("HWID", "Son HWID:", hwid)
    return hwid
end

-- Executor tespiti
function KeyValidator:GetExecutor()
    self:DetailedLog("Executor", "Executor tespit ediliyor...")
    
    -- identifyexecutor veya getexecutorname kullanmayı dene
    local executorName = nil
    
    pcall(function()
        if identifyexecutor then
            executorName = identifyexecutor()
            self:DetailedLog("Executor", "identifyexecutor() ile tespit edildi:", executorName)
        end
    end)
    
    if not executorName or executorName == "" then
        pcall(function()
            if getexecutorname then
                executorName = getexecutorname()
                self:DetailedLog("Executor", "getexecutorname() ile tespit edildi:", executorName)
            end
        end)
    end
    
    -- Sonuç geçersizse veya "function: 0x" formatındaysa
    if not executorName or executorName == "" or string.match(executorName, "^function: 0x") then
        -- Bilinen executor'ları kontrol et
        local executors = {
            ["Synapse X"] = function() return syn ~= nil end,
            ["ScriptWare"] = function() return getgenv().script_ware_identity ~= nil end,
            ["Krnl"] = function() return getgenv().KRNL_LOADED ~= nil end,
            ["Fluxus"] = function() return getgenv().fluxus ~= nil end,
            ["Oxygen U"] = function() return getgenv().OxygenU ~= nil end,
            ["JJSploit"] = function() return getgenv().JJSploit ~= nil end,
            ["Electron"] = function() return getgenv().is_electron ~= nil end,
            ["Sentinel"] = function() return getgenv().sentinel ~= nil end,
            ["ProtoSmasher"] = function() return getgenv().PROTOSMASHER_LOADED ~= nil end,
            ["Sirhurt"] = function() return getgenv().SIRHURT_LOADED ~= nil end,
            ["Coco Z"] = function() return getgenv().cocoz ~= nil end,
            ["Temple"] = function() return getgenv().temple ~= nil end,
            ["Arceus X"] = function() return getgenv().arceus_x ~= nil end,
            ["Delta"] = function() return getgenv().delta ~= nil end
        }
        
        for name, checkFn in pairs(executors) do
            local success, result = pcall(checkFn)
            if success and result then
                executorName = name
                self:DetailedLog("Executor", "Değişkenler ile tespit edildi:", name)
                break
            end
        end
    end
    
    -- Hala tespit edilemezse
    if not executorName or executorName == "" or string.match(executorName, "^function: 0x") then
        executorName = "Solara"
        self:DetailedLog("Executor", "Varsayılan executor adı kullanıldı: Solara")
    end
    
    return executorName
end

-- Oyuncu bilgilerini al
function KeyValidator:GetPlayerInfo()
    local player = nil
    
    -- Oyuncu nesnesini güvenli bir şekilde al
    local players = safeGetService("Players")
    
    if players and players.LocalPlayer then
        player = players.LocalPlayer
    else
        self:Log("Oyuncu bilgileri alınamadı")
        return {
            Username = "Unknown",
            DisplayName = "Unknown",
            AccountAge = 0,
            UserId = 0
        }
    end
    
    -- Display name kontrolü
    local displayName = "Unknown"
    pcall(function()
        displayName = player.DisplayName or player.Name
    end)
    
    local result = {
        Username = player.Name,
        DisplayName = displayName,
        AccountAge = player.AccountAge,
        UserId = player.UserId
    }
    
    self:Log("Oyuncu bilgileri alındı")
    return result
end

-- API'ye istek gönderme ve doğrulama
function KeyValidator:ValidateKey(key, userId, username)
    if not key then
        self:Log("Anahtar boş olamaz")
        return {
            success = false,
            message = "Anahtar boş olamaz",
            error_code = "INVALID_KEY"
        }
    end
    
    -- String olmayan değerleri string'e çevir
    if type(key) ~= "string" then
        key = tostring(key)
    end
    
    -- Boş string kontrolü
    if key == "" then
        self:Log("Anahtar boş string")
        return {
            success = false,
            message = "Anahtar boş olamaz",
            error_code = "INVALID_KEY"
        }
    end
    
    -- Önce kaydedilmiş anahtarı kontrol et
    local savedKeyData = self:CheckSavedKey(key)
    if savedKeyData then
        self:Log("Kaydedilmiş anahtar kullanılıyor")
        return savedKeyData
    end
    
    -- HWID al
    local hwid = self:GetHWID()
    
    -- Oyuncu bilgilerini al
    local playerInfo = self:GetPlayerInfo()
    
    -- API isteği için veri hazırla
    local requestData = {
        key = key,
        hwid = hwid,
        username = playerInfo.Username or username or "Unknown",
        user_id = playerInfo.UserId or userId or 0,
        displayname = playerInfo.DisplayName or "Unknown",
        accountage = playerInfo.AccountAge or 0,
        executor = self:GetExecutor()
    }
    
    -- Güvenlik imzası oluştur
    local timestamp = tostring(os.time())
    local signature = self:GenerateSignature(requestData, timestamp)
    
    -- İstek verilerini şifrele
    local httpService = safeGetService("HttpService")
    local jsonData = httpService:JSONEncode(requestData)
    local encryptedData = self:ObfuscateString(jsonData)
    
    -- API isteği için veri hazırla
    local apiRequestData = {
        data = encryptedData,
        signature = signature,
        timestamp = timestamp,
        version = "2.1"
    }
    
    -- API isteği gönder
    local jsonRequestData = httpService:JSONEncode(apiRequestData)
    
    local headers = {
        ["Content-Type"] = "application/json",
        ["X-Kanistay-Signature"] = signature,
        ["X-Kanistay-Client"] = "KeyValidator-v2.1"
    }
    
    self:Log("API isteği gönderiliyor...")
    
    -- Farklı HTTP kütüphanelerini dene
    local success, response
    
    -- Synapse X
    if syn and syn.request then
        self:Log("Synapse X HTTP API kullanılıyor")
        success, response = pcall(function()
            return syn.request({
                Url = self.Config.ApiUrl,
                Method = "POST",
                Headers = headers,
                Body = jsonRequestData
            })
        end)
    -- Standard HTTP
    elseif http and http.request then
        self:Log("Standard HTTP API kullanılıyor")
        success, response = pcall(function()
            return http.request({
                Url = self.Config.ApiUrl,
                Method = "POST",
                Headers = headers,
                Body = jsonRequestData
            })
        end)
    -- Generic request
    elseif request then
        self:Log("Generic request API kullanılıyor")
        success, response = pcall(function()
            return request({
                Url = self.Config.ApiUrl,
                Method = "POST",
                Headers = headers,
                Body = jsonRequestData
            })
        end)
    -- Roblox HttpService
    else
        self:Log("Roblox HttpService kullanılıyor")
        success, response = pcall(function()
            local httpService = safeGetService("HttpService")
            local result = httpService:PostAsync(
                self.Config.ApiUrl,
                jsonRequestData,
                Enum.HttpContentType.ApplicationJson,
                false,
                headers
            )
            return {
                Body = result,
                StatusCode = 200,
                Success = true
            }
        end)
    end
    
    -- HTTP isteği başarısız oldu mu?
    if not success then
        self:Log("HTTP isteği başarısız:", response)
        return {
            success = false,
            message = "Sunucuya bağlanılamadı: " .. tostring(response),
            error_code = "CONNECTION_ERROR"
        }
    end
    
    -- Yanıtı işle
    local apiResponse = {
        Body = response.Body,
        StatusCode = response.StatusCode,
        Success = response.StatusCode == 200
    }
    
    return self:ProcessResponse(apiResponse)
end

-- API yanıtını işleme
function KeyValidator:ProcessResponse(response)
    self:DetailedLog("ProcessResponse", "Yanıt işleniyor, durum kodu:", response.StatusCode)
    
    -- Yanıt başarısız mı?
    if not response.Success then
        self:DetailedLog("ProcessError", "Yanıt başarısız, durum kodu:", response.StatusCode)
        return {
            success = false,
            message = "Sunucu yanıt vermedi veya hata döndürdü: " .. (response.StatusCode or "bilinmiyor"),
            error_code = "SERVER_ERROR"
        }
    end
    
    -- Yanıt boş mu?
    if not response.Body or response.Body == "" then
        self:DetailedLog("ProcessError", "Yanıt boş")
        return {
            success = false,
            message = "Sunucu boş yanıt döndürdü",
            error_code = "EMPTY_RESPONSE"
        }
    end
    
    -- Ham yanıtı logla
    self:DetailedLog("RawResponse", "Ham yanıt:", response.Body)
    
    -- Yanıtı JSON olarak ayrıştır
    local httpService = safeGetService("HttpService")
    local success, parsedResponse = pcall(function()
        return httpService:JSONDecode(response.Body)
    end)
    
    -- JSON ayrıştırma hatası
    if not success then
        self:DetailedLog("ProcessError", "JSON ayrıştırma hatası:", parsedResponse)
        self:DetailedLog("RawResponse", "Ham yanıt:", response.Body)
        return {
            success = false,
            message = "Sunucu yanıtı ayrıştırılamadı",
            error_code = "INVALID_RESPONSE_FORMAT"
        }
    end
    
    -- Yanıt formatı doğru mu?
    if type(parsedResponse) ~= "table" then
        self:DetailedLog("ProcessError", "Yanıt tablo değil, tip:", type(parsedResponse))
        return {
            success = false,
            message = "Sunucu yanıtı geçersiz format",
            error_code = "INVALID_RESPONSE_FORMAT"
        }
    end
    
    -- Şifreli yanıt mı kontrol et
    if parsedResponse.encrypted and parsedResponse.data then
        self:DetailedLog("ProcessResponse", "Şifreli yanıt tespit edildi, çözülüyor...")
        self:DetailedLog("EncryptedData", "Şifreli veri:", parsedResponse.data)
        self:DetailedLog("EncryptedData", "Şifreli veri uzunluğu:", #parsedResponse.data)
        
        -- Şifreli veriyi çöz
        local decryptedData = ""
        local decryptSuccess, decryptResult = pcall(function()
            -- Executor'da crypt.base64decode kullanmayı dene
            if crypt and crypt.base64decode then
                local decoded = crypt.base64decode(parsedResponse.data)
                return self:DeobfuscateString(decoded)
            end
            
            -- Normal şifre çözme
            return self:DeobfuscateString(parsedResponse.data)
        end)
        
        if decryptSuccess then
            decryptedData = decryptResult
            self:DetailedLog("DecryptedData", "Çözülmüş veri uzunluğu:", #decryptedData)
            
            -- İlk 100 karakteri göster
            local previewLength = math.min(100, #decryptedData)
            self:DetailedLog("DecryptedData", "Çözülmüş veri önizleme:", 
                string.sub(decryptedData, 1, previewLength) .. (#decryptedData > previewLength and "..." or ""))
        else
            self:DetailedLog("DecryptError", "Şifre çözme hatası:", decryptResult)
            return {
                success = false,
                message = "Şifreli yanıt çözülemedi: " .. tostring(decryptResult),
                error_code = "DECRYPTION_ERROR"
            }
        end
        
        -- Çözülmüş veriyi JSON olarak ayrıştır
        local jsonSuccess, decryptedResponse = pcall(function()
            return httpService:JSONDecode(decryptedData)
        end)
        
        if not jsonSuccess then
            self:DetailedLog("ProcessError", "Şifreli yanıt JSON olarak ayrıştırılamadı:", decryptedResponse)
            self:DetailedLog("DecryptedData", "Çözülmüş veri:", decryptedData)
            
            -- Alternatif olarak manuel JSON ayrıştırma dene
            local manualSuccess, manualResult = pcall(function()
                -- Basit bir JSON ayrıştırma denemesi
                if string.sub(decryptedData, 1, 1) == "{" and string.sub(decryptedData, -1) == "}" then
                    local success = string.match(decryptedData, '"success":%s*(%a+)')
                    local message = string.match(decryptedData, '"message":%s*"([^"]+)"')
                    
                    return {
                        success = success == "true",
                        message = message or "Yanıt ayrıştırılamadı",
                        manual_parse = true
                    }
                end
                return nil
            end)
            
            if manualSuccess and manualResult then
                self:DetailedLog("ManualParse", "Manuel JSON ayrıştırma başarılı")
                return manualResult
            end
            
            return {
                success = false,
                message = "Şifreli yanıt JSON olarak ayrıştırılamadı",
                error_code = "INVALID_JSON_FORMAT"
            }
        end
        
        -- Debug modunda çözülmüş yanıtı göster
        if self.Config.Debug then
            self:DetailedLog("DecryptedResponse", "success:", decryptedResponse.success)
            self:DetailedLog("DecryptedResponse", "message:", decryptedResponse.message)
            
            if type(decryptedResponse) == "table" then
                for k, v in pairs(decryptedResponse) do
                    if k ~= "permissions" then -- permissions tablosu çok uzun olabilir
                        self:DetailedLog("DecryptedResponse", k .. ":", tostring(v))
                    end
                end
            end
        end
        
        -- ÖNEMLİ: Yasaklanmış kullanıcı kontrolü - her zaman success=true olarak işaretlenmeli
        if decryptedResponse.banned == true then
            decryptedResponse.success = true
            self:DetailedLog("BannedUser", "Yasaklanmış kullanıcı durumu success=true olarak güncellendi")
        end
        
        -- Başarılı doğrulama sonrası anahtarı kaydet
        if decryptedResponse.success == true and not decryptedResponse.banned and not decryptedResponse.keyless then
            self:DetailedLog("SaveKey", "Başarılı doğrulama, anahtar kaydediliyor")
            self:SaveKey(self.Config.Key, decryptedResponse)
        end
        
        self:DetailedLog("Result", "Doğrulama sonucu:", decryptedResponse.success, "Mesaj:", decryptedResponse.message)
        return decryptedResponse
    end
    
    -- Normal yanıt işleme (şifrelenmemiş)
    if self.Config.Debug then
        self:DetailedLog("ResponseData", "success:", parsedResponse.success)
        self:DetailedLog("ResponseData", "message:", parsedResponse.message)
        
        if parsedResponse.data then
            self:DetailedLog("ResponseData", "data türü:", type(parsedResponse.data))
            if type(parsedResponse.data) == "table" then
                for k, v in pairs(parsedResponse.data) do
                    if k ~= "permissions" then -- permissions tablosu çok uzun olabilir
                        self:DetailedLog("ResponseData", "data." .. k .. ":", v)
                    end
                end
                
                -- Permissions tablosunu ayrıca göster
                if parsedResponse.data.permissions then
                    self:DetailedLog("ResponseData", "permissions sayısı:", #parsedResponse.data.permissions)
                end
            end
        end
    end
    
    -- Yanıt içeriğinde success var mı?
    if parsedResponse.success == nil then
        self:DetailedLog("ProcessError", "Yanıtta success alanı yok")
        return {
            success = false,
            message = "Sunucu yanıtı geçersiz format (success alanı yok)",
            error_code = "INVALID_RESPONSE_FORMAT"
        }
    end
    
    -- ÖNEMLİ: Yasaklanmış kullanıcı kontrolü - her zaman success=true olarak işaretlenmeli
    if parsedResponse.banned == true then
        parsedResponse.success = true
        self:DetailedLog("BannedUser", "Yasaklanmış kullanıcı durumu success=true olarak güncellendi")
    end
    
    -- Başarılı doğrulama sonrası anahtarı kaydet
    if parsedResponse.success == true and not parsedResponse.banned and not parsedResponse.keyless then
        self:DetailedLog("SaveKey", "Başarılı doğrulama, anahtar kaydediliyor")
        self:SaveKey(self.Config.Key, parsedResponse)
    end
    
    -- Sonucu döndür
    self:DetailedLog("Result", "Doğrulama sonucu:", parsedResponse.success, "Mesaj:", parsedResponse.message)
    return parsedResponse
end

-- Anahtar durumunu kontrol et
function KeyValidator:CheckKeyStatus(key)
    local result = self:ValidateKey(key)
    
    if result.success then
        return {
            active = true,
            message = "Anahtar aktif"
        }
    elseif result.error_code == "INACTIVE_KEY" then
        return {
            active = false,
            message = "Anahtar deaktif edilmiş"
        }
    elseif result.error_code == "EXPIRED_KEY" then
        return {
            active = false,
            message = "Anahtarın süresi dolmuş"
        }
    else
        return {
            active = false,
            message = result.message or "Geçersiz anahtar"
        }
    end
end

-- LogExpiredKey fonksiyonu
function KeyValidator:LogExpiredKey(key, userId, username)
    self:Log("Logging expired key:", key, "for user:", username)
    -- Burada API çağrısı yapılabilir
    pcall(function()
        local apiUrl = self.Config and self.Config.ApiUrl or "https://kanistay-key-validator.workers.dev"
        local endpoint = apiUrl .. "/log-expired-key"
        
        local data = {
            key = key,
            hwid = self:GetHWID(),
            executor = self:GetExecutor(),
            userId = userId or 0,
            username = username or "Unknown",
            timestamp = os.time()
        }
        
        local httpService = safeGetService("HttpService")
        local jsonData = httpService:JSONEncode(data)
        
        local response = self:HttpRequest(
            endpoint,
            "POST",
            {
                ["Content-Type"] = "application/json",
                ["X-Kanistay-Client"] = "KeyValidator-v2.1"
            },
            jsonData
        )
        
        if response and response.Success then
            self:Log("Expired key logged successfully")
        else
            self:Log("Failed to log expired key:", response and response.Body or "unknown error")
        end
    end)
end

-- Bu satır çok önemli - KeyValidator modülünü döndür
self = KeyValidator
return KeyValidator 
